# stage file using a substring of the file name
# eg:
# $ git status -s
#  M  redline/apps/redline_web_store/something.js
#  M  redline/apps/redline_web_store/something.eex
# $ gti-add .js
# M   redline/apps/redline_web_store/something.js
#  M  redline/apps/redline_web_store/something.eex
function git-add () {
    git add $(git status -s | awk -F ' ' '{print $2}' | grep $1) && git status -s
}

# unstage changes to a file using a substring of the file name
# eg:
# $ git-unstage .js
function git-unstage () {
    git reset HEAD -- $(git status -s | awk -F ' ' '{print $2}' | grep $1)
}

# discard changes to a file using a substring of the file name
# eg:
# $ git-discard .js
function git-discard () {
    git checkout -- $(git status -s | awk -F ' ' '{print $2}' | grep $1) && git status -s
}

# commit changes with auto-prepended JIRA ticket number
# eg:
# $ git branch
#   JIRA-123-things
# * JIRA-321-stuff
# $ git-commit "my descriptive commit message"
# [JIRA-321 0099cc9ad4] JIRA-321 my descriptive commit message
#  3 files changed, 4 insertions(+), 7 deletions(-)
function git-commit () {
    git commit -m "$(git rev-parse --abbrev-ref HEAD | sed 's/^[^A-Z]*\([A-Z]\{2,\}-[0-9]\+\).*$/\1/') $1"
}

# diff file using a substring of the file name
# eg:
# $ git-diff .js
function git-diff () {
    git diff $(git status -s | awk -F ' ' '{print $2}' | grep $1)
}

# checkout a branch using a substring of the branch name
# eg:
# $ git-checkout JIRA-123
function git-checkout () {
    git checkout $(git branch | awk -F ' ' '{print $1}' | grep $1) && git branch
}

# shortcut for setting upstream
function git-push () {
    git push --set-upstream ${1:-origin} $(git rev-parse --abbrev-ref HEAD | awk -F ' ' '{print $1}')
}

function git-status () {
    git status -s
}

function git-branch-cleanup () {
    git stash && \
    git checkout ${1:-master} && \
    git branch --merged | egrep -v "(^\*|master|main|dev|keep)" | xargs git branch -d
}

function git-branch () {
    git add . && \
    git stash && \
    git checkout master && \
    git fetch upstream && \
    git pull upstream master && \
    git checkout -b $1
}


# reset a changed file to its master version using a substring of the file name
# eg:
# $ git diff --name-only master
#   redline/apps/redline_web_store/something.js
#   redline/apps/redline_web_store/something.eex
# $ git-reset-from-master .js
# (resets something.js to the version from master)
function git-reset-from-master () {
    local files=$(git diff --name-only master | grep $1)
    if [ -z "$files" ]; then
        echo "No files matching '$1' found"
        return 1
    fi
    git checkout master -- $files && git status -s
}

# commit staged changes and squash into previous commit, keeping the previous commit message

# commit staged changes and squash into previous commit, keeping the previous commit message
# eg:
# $ git-squash-commit
# (commits staged changes and squashes into previous commit)
function git-squash-commit () {
    # Check if there are unstaged changes
    if ! git diff-files --quiet; then
        git stash push --keep-index -m "git-squash-commit temporary stash" && \
        git commit --fixup=HEAD && \
        GIT_SEQUENCE_EDITOR=true git rebase --interactive --autosquash HEAD~2 && \
        git stash pop
    else
        git commit --fixup=HEAD && \
        GIT_SEQUENCE_EDITOR=true git rebase --interactive --autosquash HEAD~2
    fi
}
